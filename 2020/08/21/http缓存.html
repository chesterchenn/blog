<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>HTTP缓存 | 主页</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="HTTP缓存" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="HTTP 缓存可以很好优化 Web 性能，不仅能减少数据传输，缓解网络瓶颈，降低服务器的要求，降低距离时延。" />
<meta property="og:description" content="HTTP 缓存可以很好优化 Web 性能，不仅能减少数据传输，缓解网络瓶颈，降低服务器的要求，降低距离时延。" />
<link rel="canonical" href="/blog/2020/08/21/http%E7%BC%93%E5%AD%98.html" />
<meta property="og:url" content="/blog/2020/08/21/http%E7%BC%93%E5%AD%98.html" />
<meta property="og:site_name" content="主页" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-08-21T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="HTTP缓存" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2020-08-21T00:00:00+00:00","datePublished":"2020-08-21T00:00:00+00:00","description":"HTTP 缓存可以很好优化 Web 性能，不仅能减少数据传输，缓解网络瓶颈，降低服务器的要求，降低距离时延。","headline":"HTTP缓存","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2020/08/21/http%E7%BC%93%E5%AD%98.html"},"url":"/blog/2020/08/21/http%E7%BC%93%E5%AD%98.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css">
  <link rel="icon" type="image/x-icon" href="/blog/assets/favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" /><link type="application/atom+xml" rel="alternate" href="/blog/feed.xml" title="主页" />
    






  
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">主页</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/about/">关于</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">HTTP缓存</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-08-21T00:00:00+00:00" itemprop="datePublished">Aug 21, 2020
      </time></p>
    <span>
      
        <!--  -->
        <span class="highligher-rouge"><a href="/blog/tag/2020"><i>2020</i></a></span>
      
        <!--  -->
        <span class="highligher-rouge"><a href="/blog/tag/http"><i>http</i></a></span>
      
    </span>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>HTTP 缓存可以很好优化 Web 性能，不仅能减少数据传输，缓解网络瓶颈，降低服务器的要求，降低距离时延。</p>

<p>一般只有 get 请求才会被缓存，这里一般是指 get 资源情况。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5fe072c8dd3464f8de15709b22f743f~tplv-k3u1fbpfcp-watermark.image" alt="缓存机制流程" /></p>

<p>图片来源：<a href="https://juejin.cn/post/6844904163172679688">https://juejin.cn/post/6844904163172679688</a></p>

<p>通常浏览器缓存策略分为两种：强缓存和协商缓存</p>

<ul>
  <li><a href="#强缓存">强缓存</a>
    <ul>
      <li><a href="#expires">Expires</a></li>
      <li><a href="#cache-control">Cache-Control</a></li>
      <li><a href="#pragma">Pragma</a></li>
    </ul>
  </li>
  <li><a href="#协商缓存">协商缓存</a>
    <ul>
      <li><a href="#etag">ETag</a></li>
      <li><a href="#last-modified">Last-Modified</a></li>
    </ul>
  </li>
</ul>

<h2 id="浏览器策略">浏览器策略</h2>

<p>在测试的过程中发现强缓存跟浏览器缓存策略有关的一些有意思的东西。</p>

<p>下面是 nodejs 简单实现一个 get 请求并返回一个字符串，同时实现强缓存。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">http</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">createServer</span><span class="p">((</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nf">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span>
    <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">,</span>
    <span class="dl">'</span><span class="s1">Cache-Control</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">max-age=3600</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 设置强缓存</span>
  <span class="p">});</span>
  <span class="nx">res</span><span class="p">.</span><span class="nf">end</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">server</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="mi">8000</span><span class="p">);</span>
</code></pre></div></div>

<p>首先访问一次，让浏览器产生缓存。</p>

<p>由于浏览器的缓存策略，当我们使用 F5 刷新的时候，每次都会从服务器获取数据。以下分别是在 firefox 与 chromium 中的表现。</p>

<p><img src="/blog/images/http_firefox.png" alt="http_firefox" />
<img src="/blog/images/http_chromium.png" alt="http_chromium" /></p>

<p>但是当我们通过 url 直接进入页面的时候，我们可以发现都是从强缓存中获取数据。以下分别是在 firefox 与 chromium 中的表现。</p>

<p><img src="/blog/images/http_firefox_2.png" alt="http_firefox_2" />
<img src="/blog/images/http_chromium_2.png" alt="http_chromium_2" /></p>

<p>更有意思的是，firefox 中从在当前窗口输入 url，无论如何都是从强缓存中获取数据。</p>

<p>而 chromium 中首次进入的时候是从强缓存中获取数据，但是在当前窗口输入 url 会直接从服务器获取数据，类似 F5 刷新。但是如果你跳转到其他页面，再此输入 url，又是从强缓存中获取数据。</p>

<p>从网上查询到的部分资料如下：</p>

<ol>
  <li>打开网页，地址栏输入地址： 查找强制缓存中是否有匹配。如有则使用；如没有则发送网络请求。</li>
  <li>普通刷新 (F5)：跳过强缓存， 协商缓存是可用的。</li>
  <li>强制刷新 (Ctrl + F5)：跳过强制缓存和协商缓存，发送的请求头部均带有 Cache-control:no-cache(为了兼容，还带了 Pragma:no-cache)。</li>
</ol>

<h2 id="强缓存">强缓存</h2>

<p>强缓存即本地缓存，在缓存期间不需要请求，状态码直接返回 200。</p>

<p>实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control （都用于设置资源过期时间）</p>

<p>需要注意几个首部的优先级：Pragma &gt; Cache-Control &gt; Expires</p>

<h2 id="expires">Expires</h2>

<p>Expires 响应头包含日期/时间。Expires 的值返回一个 GMT（格林尼治时间）, 来告诉浏览器资源缓存过期时间。</p>

<pre><code class="language-plain">Expires: &lt;http-date&gt;
Expires: Mon, 24 Aug 2020 11:12:01 GMT
</code></pre>

<p>Expires 首部和 Cache-Control: max-age 首部所做的事情本质是一样的，但由于 Cache-Control 首部使用的是相对时间而不是绝对时间，所以我们更倾向于使用比较新的 Cache-Control 首部。</p>

<h2 id="cache-control">Cache-Control</h2>

<p>缓存请求指令</p>

<pre><code class="language-plain">Cache-Control: max-age=&lt;seconds&gt;
Cache-Control: max-stale[=&lt;seconds&gt;]
Cache-Control: min-fresh=&lt;seconds&gt;
Cache-control: no-cache
Cache-control: no-store
Cache-control: no-transform
Cache-control: only-if-cached
</code></pre>

<p>缓存响应指令</p>

<pre><code class="language-plain">Cache-control: must-revalidate
Cache-control: no-cache
Cache-control: no-store
Cache-control: no-transform
Cache-control: public
Cache-control: private
Cache-control: proxy-revalidate
Cache-Control: max-age=&lt;seconds&gt;
Cache-control: s-maxage=&lt;seconds&gt;
</code></pre>

<h2 id="pragma">Pragma</h2>

<p>Pragma 是一个在 HTTP/1.0 中规定的通用首部。设置 <code class="language-plaintext highlighter-rouge">Pragma: no-cache</code> 当客户端请求带有此字段时，会表示客户端禁用缓存，与 <code class="language-plaintext highlighter-rouge">Cache-Control: no-cache</code> 效果一致。</p>

<p>当浏览器设置禁用缓存时，会同时启动 <code class="language-plaintext highlighter-rouge">Pragma: no-cache</code> 和 <code class="language-plaintext highlighter-rouge">Cache-Control: no-cache</code>，兼容 HTTP/1.0。</p>

<h2 id="协商缓存">协商缓存</h2>

<p>协商缓存，如果本地缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要向服务器发送请求，如果缓存有效会返回 304。</p>

<h2 id="etag">ETag</h2>

<p>ETag，entity tag 也叫实体标签。如果资源给定的 URL 标签变化了，一定会生成新的 Etag 标签。</p>

<pre><code class="language-plain">ETag: W/"&lt;etag_value&gt;"
ETag: "&lt;etag_value&gt;"
</code></pre>

<p><code class="language-plaintext highlighter-rouge">W/</code>（区分大小写）表示使用弱验证器。弱验证更加容易生成，比较的作用更小，强验证更加理想，但是比较难生成。</p>

<p><code class="language-plaintext highlighter-rouge">&lt;etag_value&gt;</code> 代表所请求的资源的唯一实体标签，是用双引号包括的字符串。通常情况下，ETag 的值可能是内容的哈希值，也可以是最后修改的时间戳，或者是一个修订号。</p>

<p>跟 ETag 相关的条件首部是 If-Match 和 If-No-Match。</p>

<h3 id="避免半空碰撞">避免半空碰撞</h3>

<p>是用 ETag 和 If-Match 可以避免半空中碰撞。</p>

<p>例如，当我们编辑一篇文档时，当前内容包含了一个 <code class="language-plaintext highlighter-rouge">ETag: "7938fa78ac98cafee889"</code> 的响应头部，当我们需要保存的时候时候，我们发起一个包含 <code class="language-plaintext highlighter-rouge">If-Match: "7938fa78ac98cafee889"</code> 的头部去检查新鲜度。如果该哈希值未匹配，这说明我们该文档在我们编辑的过程中被修改过，我们会得到一个 <code class="language-plaintext highlighter-rouge">412 Precondition Failed</code> 的错误。</p>

<h3 id="缓存未修改的资源">缓存未修改的资源</h3>

<p>另一个典型的应用场景就是使用 ETag 和 If-None-Match 缓存未修改的资源。当用户重新访问一个 URL 或者需要更新时，客户端会发送<code class="language-plaintext highlighter-rouge">If-None-Match: "7938fa78ac98cafee889"</code> 的请求头部，当服务器的 ETag 与 该值相同，则会发送一个没有实体（body） <code class="language-plaintext highlighter-rouge">304 Not Modified</code> 的状态响应。</p>

<p>以下是一个简单的 nodejs 实现的 ETag 缓存响应。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">http</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">crypto</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">crypto</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">createServer</span><span class="p">((</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">buf</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nf">readFileSync</span><span class="p">(</span><span class="dl">'</span><span class="s1">./index.html</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">ETag</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">"</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">crypto</span><span class="p">.</span><span class="nf">createHash</span><span class="p">(</span><span class="dl">'</span><span class="s1">md5</span><span class="dl">'</span><span class="p">).</span><span class="nf">update</span><span class="p">(</span><span class="nx">buf</span><span class="p">).</span><span class="nf">digest</span><span class="p">(</span><span class="dl">'</span><span class="s1">hex</span><span class="dl">'</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">"</span><span class="dl">'</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">clientETag</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">headers</span><span class="p">[</span><span class="dl">'</span><span class="s1">if-none-match</span><span class="dl">'</span><span class="p">];</span>

  <span class="k">if </span><span class="p">(</span><span class="nx">clientETag</span> <span class="o">===</span> <span class="nx">ETag</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">304</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nf">end</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="nx">res</span><span class="p">.</span><span class="nf">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span>
    <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">ETag</span><span class="p">:</span> <span class="nx">ETag</span><span class="p">,</span>
  <span class="p">});</span>
  <span class="nx">res</span><span class="p">.</span><span class="nf">end</span><span class="p">();</span>
<span class="p">});</span>

<span class="nx">server</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="mi">8000</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="last-modified">Last-Modified</h2>

<p>Last-Modified/If-Modified-Since 匹配成对出现。</p>

<pre><code class="language-plain">Last-Modified: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT
</code></pre>

<p>Last-Modified 响应 HTTP 报头包含在其原始服务器认为该资源的最后修改日期和时间。跟 Last-Modified 相关的条件首部 If-Modified-Since 和 If-Unmodified-Since。</p>

<h3 id="etag-与-last-modified-比较">ETag 与 Last-Modified 比较</h3>

<ul>
  <li>
    <p>ETag 比 Last-Modified 优先度更高。</p>
  </li>
  <li>
    <p>因为如果资源发生变化，Etag 就会发生变化。而 Last-Modified 无法识别秒单位里的修改，Last-Modified 不会进行更新。</p>
  </li>
  <li>
    <p>ETag 服务器需要根据资源计算，有轻微的性能损耗。</p>
  </li>
  <li>
    <p>Last-Modified 无法保证客户端和服务端时间一致性。</p>
  </li>
</ul>

<h2 id="其他">其他</h2>

<p>上述的首部字段均能让客户端决定是否向服务器发送请求，比如设置的缓存时间未过期，那么自然直接从本地缓存取数据即可（在 chrome 下表现为 200 from cache），若缓存时间过期了或资源不该直接走缓存，则会发请求到服务器去。但是仅仅是已缓存文档过期了并不意味着它和原始服务器上目前处于活跃的文档有实际的区别。这只是意味着到了要进行核对的时间，这种情况被称为“服务器再验证”</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li>《HTTP 权威指南》</li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ">MDN:HTTP 缓存</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires">MDN:Expires</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">MDN:Cache-Control</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma">MDN:Pragma</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag">MDN:ETag</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified">MDN:Last-Modified</a></li>
  <li><a href="https://juejin.cn/post/7008369315749560333">离线化/长缓存方案探究与实践</a></li>
</ul>

  </div><a class="u-url" href="/blog/2020/08/21/http%E7%BC%93%E5%AD%98.html" hidden></a>
</article>

      </div>
    </main>

    <div class="top">
      <div class="top__tri"></div>
    </div><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>
  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col one-half">
      <h2 class="footer-heading">结尾处</h2>
        <ul class="contact-list">
          <li class="p-name"></li><li><a class="u-email" href="mailto:chesterchenn@outlook.com">chesterchenn@outlook.com</a></li><li>
              <a href="/blog/feed.xml">
                <svg class="svg-icon orange">
                  <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
                </svg><span>Subscribe</span>
              </a>
            </li>
        </ul>
      </div>

      <div class="footer-col one-half">
        <p>看自己超过两周之前写的代码就跟之前没看过一样。</p>
      </div>

      <div class="social-links"><ul class="social-media-list"><li><a href="https://github.com/chesterchenn" title="chesterchenn"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a href="https://twitter.com/chesterchenn" title="chesterchenn"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>
    </div>
  </div>
</footer>
<script src="/blog/assets/js/top.js"></script>

  </body>

</html>
