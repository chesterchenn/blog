# 线性表( Linked List )
Created: 2018-08-17  
Last Modified: 2018-08-27  

线性表(Linear List)是一种线性结构。线性表是由n(n ≥ 0)个数据元素的有限序列。

## 非空线性表的结构特点：
  - 存在一个唯一没有前驱的数据元素(头元素)
  - 存在一个唯一没有后驱的数据元素(尾元素)
  - 除了头元素，尾元素，每个元素的均有一个直接前驱和一个直接后继的数据元素。

## 线性表的存储结构：
  - 顺序存储 - 顺序表
  - 链式存储 - 链表
    - 单链表
    - 双链表
    - 循环链表
    - 静态链表

## 线性存储 - 顺序表
顺序表是指用一组地址连续的存储单元依次存储数据元素的线性结构。优点：可以随机存取表中的元素。缺点：插入和删除操作需要移动元素。
```
#define LIST_INIT_SIZE 10
#define LIST_INCREMENT 2
typeof struct {
  ElemType *elem;   // 数据元素基址 
  int length;       // 顺序表当前长度 
  int listsize;     // 顺序表表长  
}Sqlist;
```
基本操作：
```
//====================
// 初始化空顺序线性表 
//====================
void InitList(SqList *L) {
  L->elem=malloc(LIST_INIT_SIZE*sizeof(ElemType));
  if(!->elem) exit(OVERFLOW);                      // 存储分配失败 
  L->length=0;
  L->listsize=LIST_INIT_SIZE;
}

//=================
// 销毁顺序线性表L 
//=================
void DestroyList(SqList *L) {
  free(L->elem);
  L->elem=NULL;
  L->length=0;
  L->listsize=0;
}

//===============
// 将L重置为空表 
//===============
void ClearList(SqList *L) {
  L->length=0;
}

//=============================================
// 判断是否为空表，若是返回TRUE，否则返回FALSE 
//=============================================
Status ListEmpty(SqList L) {
  if(L.length==0) return TRUE;
  else return FALSE;
}

//===================
// 返回顺序表L的长度 
//===================
int ListLength(SqList L) {
  return L.length;
}

//=========================
// 用e返回L中第i个元素的值 
//=========================
Status GetElem(SqList L, int i, ElemType *e) {
  if (i<1 || i>L.length) return ERROR;
  *e = *(L.elem+i-1);
  return OK;
}

//======================================================================
// 返回L中第一个与e满足关系compare()的数据元素的位序，若不存在，则返回0 
//======================================================================
int Locate(SqList L, ElemType e, Status(*compare)(ElemType, ElemType)) {
  ElemType *p;
  int i=1;
  p=L.elem;
  while(i<=L.length && !compare(*p++, e)) ++i;
  if(i<=L.length) return i;
  else return 0;
}

//========================================================
// 返回元素的前驱，元素不能为头元素，元素不存在则操作失败 
//========================================================
Status PriorElem(SqList L, ElemType cur_e, ElemType *pre_e) {
  int i=2;
  ElemType *p=L.elem+1;
  while(i<=L.length && *p!=cur_e) {
    p++;
    i++;
  }
  if (i>L.length) return INFEASIBLE;
  else {
    *pre_e=*--p;
    return OK;
  }
}

//========================================================
// 返回元素的后继，元素不能为尾元素，元素不存在则操作失败 
//========================================================
Status NextElem(SqList L, ElemType cur_e, ElemType *next_e) {
  int i=1;
  ElemType *p=L.elem;
  while(i<L.length && *p!=cur_e) {
    i++;
    p++;
  }
  if(i==Length) return INFEASIBLE;
  else {
    *next_e=*++p;
    return OK;
  }
}

//==================
// 插入元素，长度+1 
//==================
Status ListInsert(SqList *L, int i, ElemType e) {
  ElemType *newbase, *q, *p;
  if(i<1 || i>L->length+1) return ERROR;
  if(L->length >= L->listsize) {
    newbase=realloc(L->elem, (L->listsize+LIST_INCREMENT));
    if(!newbase) exit(OVERFLOW);
    L->elem=newbase;
    L->listsize+=LIST_INCREMENT;
  }
  q=L->elem+i-1;
  for(p=L->elem+L->length-1;p>=q;--p) {
    *(p+1)=*p;
  }
  *q=e;
  ++L->length;
  return OK;
}

//=============================
// 删除元素，用e返回值，长度-1 
//=============================
Status ListDelete(SqList *L, int i, ElemType *e) {
  ElemType *p, *q;
  if(i<1||i>L->Length) return ERROR;
  p=L->elem+i-1;
  *e=*p;
  q=L->elem+L->length-1;
  for(++p;p<=q;++p) *(p-1)=*p;
  L->length--;
  return OK;
}

//==================================
// 遍历元素，依次对元素执行vi()操作 
//==================================
void ListTraverse(SqList L, void(*vi)(ElemType*)) {
  ElemType *p;
  int i;
  p=L.elem;
  for(i=1;i<L.length;i++) vi(p++);
}
```

## 链式存储 - 链表
链表是线性表里常见的数据结构，不需要连续存储到内存中。每一个节点都包括了数据项`data`以及指针域`pointer`。优点：无需确定内存大小，方便插入与删除。缺点：占用更大的内存空间(使用了指针域)，查询链表必须从头开始依次遍历查询，加大了查询时间。

### 单链表(singly linked list)
![Image](./images/SLList.png)
```
//===============
// 结构体
//===============
struct Node {
  int data;
  struct Node *next;
}

//==============
// 创建新节点
//==============
node createNode() {
  struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
  temp->next = NULL;
  return temp;
}

//===========================
// 添加节点--在前面添加节点
//===========================
void push(struct Node **head, int data) {
  struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
  temp->data = data;
  temp->next = (*head);
  (*head) = temp;
}

//======================================
// 添加节点--在指定元素后面添加添加节点
//======================================
void insertAfter(struct Node* prev, int data) {
  if (prev == NULL) {
    printf("the previous node connot be NULL");
    return;
  }
  struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
  temp->data = data;
  temp->next = prev->next;
  prev->next = temp;
}

//==========================
// 添加节点--在末尾添加节点
//==========================
void append(struct Node **head, int data) {
  struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
  struct Node *last = *head;
  temp->data = data;
  temp->next = NULL;
  if(*head==NULL) {
    *head = temp;
    return;
  }
  while (last->next != NULL) {
    last = last-next;
  }
  last->next = temp;
  return;
}

//=========================
// 删除节点--根据指定的值
//=========================
void deleteNode(struct Node **head, int key) {
  struct Node* temp = *head, *prev;
  if (temp != NULL && temp->data == key) {
    *head = temp->next;
    free(temp);
    return;
  }
  while(temp != NULL && temp->data != key) {
    prev = temp;
    temp = temp->next;
  }
  if (temp == NULL) return;
  prev->next = temp->next;
  free(temp);
}

//==========================
// 删除节点--根据指定的位置
//==========================
void deleteNode(struct Node **head, int position) {
  if (**head == NULL) return;
  struct Node* temp = *head;
  if (position == 0) {
    *head = temp -> next;
    free(temp);
    return;
  }
  for(int i=0; temp!=NULL && i<position-1; i++) {
    temp = temp->next;
  }
  if(temp == NULL || temp->next == NULL) {
    return;
  }
  struct Node *next = temp->next->next;
  free(temp->next);
  temp->next = next;
}

//============
// 删除链表
//============
void deleteList(struct Node** head) {
  struct Node* current = *head;
  struct Node* next;
  while(current != NULL) {
    next = current->next;
    free(current);
    current = next;
  }
  *head = NULL;
}

//===================
// 返回单链表的长度
//===================
void listLength() {
  int length = 0;
  struct Node* current = head;
  while(current != NULL) {
    length++;
    current = current->next;
  }
  return length;
}

//====================================================
// 查找链表是否有值key，有的话返回true，否则返回false
//====================================================
bool search(struct Node* head, int key) {
  struct Node* current = head;
  while(current != NULL) {
    if (current->data == key) return true;
    current = current->next;
  }
  return false;
}

//================================
// 获取指定位置的值，否则返回错误
//================================
int getNode(struct Node* head, int index) {
  struct Node* current = head;
  int count = 0;
  while(current != NULL) {
    if (count == index) return (current->data);
    count++;
    current = current->next;
  }
  assert(0);
}
```