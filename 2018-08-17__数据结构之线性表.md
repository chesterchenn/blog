# 线性表( Linked List )
Created: 2018-08-17  
Last Modified: 2018-08-20  

线性表(Linear List)是一种线性结构。线性表是由n(n ≥ 0)个数据元素的有限序列。

## 非空线性表的结构特点：
  - 存在一个唯一没有前驱的数据元素(头元素)
  - 存在一个唯一没有后驱的数据元素(尾元素)
  - 除了头元素，尾元素，每个元素的均有一个直接前驱和一个直接后继的数据元素。

## 线性表的存储结构：
  - 顺序存储－顺序表
  - 链式存储－链表
    - 单链表
    - 双链表
    - 循环链表

## 顺序表
顺序表是指用一组地址连续的存储单元依次存储数据元素的线性结构。优点：可以随机存取表中的元素。缺点：插入和删除操作需要移动元素。定义：
```
#define LIST_INIT_SIZE 10
#define LIST_INCREMENT 2
typeof struct {
  ElemType *elem;   /* 数据元素基址 */
  int length;       /* 顺序表当前长度 */
  int listsize;     /* 顺序表表长 */ 
}Sqlist;
```
基本操作：
```
/*====================*/
/* 初始化空顺序线性表 */
/*====================*/
void InitList(SqList *L) {
  L->elem=malloc(LIST_INIT_SIZE*sizeof(ElemType));
  if(!->elem) exit(OVERFLOW);                      /* 存储分配失败 */
  L->length=0;
  L->listsize=LIST_INIT_SIZE;
}

/*=================*/
/* 销毁顺序线性表L */
/*=================*/
void DestroyList(SqList *L) {
  free(L->elem);
  L->elem=NULL;
  L->length=0;
  L->listsize=0;
}

/*===============*/
/* 将L重置为空表 */
/*===============*/
void ClearList(SqList *L) {
  L->length=0;
}

/*=============================================*/
/* 判断是否为空表，若是返回TRUE，否则返回FALSE */
/*=============================================*/
Status ListEmpty(SqList L) {
  if(L.length==0) return TRUE;
  else return FALSE;
}

/*===================*/
/* 返回顺序表L的长度 */
/*===================*/
int ListLength(SqList L) {
  return L.length;
}

/*=========================*/
/* 用e返回L中第i个元素的值 */
/*=========================*/
Status GetElem(SqList L, int i, ElemType *e) {
  if (i<1 || i>L.length) return ERROR;
  *e = *(L.elem+i-1);
  return OK;
}

/*======================================================================*/
/* 返回L中第一个与e满足关系compare()的数据元素的位序，若不存在，则返回0 */
/*======================================================================*/
int Locate(SqList L, ElemType e, Status(*compare)(ElemType, ElemType)) {
  ElemType *p;
  int i=1;
  p=L.elem;
  while(i<=L.length && !compare(*p++, e)) ++i;
  if(i<=L.length) return i;
  else return 0;
}

/*========================================================*/
/* 返回元素的前驱，元素不能为头元素，元素不存在则操作失败 */
/*========================================================*/
Status PriorElem(SqList L, ElemType cur_e, ElemType *pre_e) {
  int i=2;
  ElemType *p=L.elem+1;
  while(i<=L.length && *p!=cur_e) {
    p++;
    i++;
  }
  if (i>L.length) return INFEASIBLE;
  else {
    *pre_e=*--p;
    return OK;
  }
}

/*========================================================*/
/* 返回元素的后继，元素不能为尾元素，元素不存在则操作失败 */
/*========================================================*/
Status NextElem(SqList L, ElemType cur_e, ElemType *next_e) {
  int i=1;
  ElemType *p=L.elem;
  while(i<L.length && *p!=cur_e) {
    i++;
    p++;
  }
  if(i==Length) return INFEASIBLE;
  else {
    *next_e=*++p;
    return OK;
  }
}

/*==================*/
/* 插入元素，长度+1 */
/*==================*/
Status ListInsert(SqList *L, int i, ElemType e) {
  ElemType *newbase, *q, *p;
  if(i<1 || i>L->length+1) return ERROR;
  if(L->length >= L->listsize) {
    newbase=realloc(L->elem, (L->listsize+LIST_INCREMENT));
    if(!newbase) exit(OVERFLOW);
    L->elem=newbase;
    L->listsize+=LIST_INCREMENT;
  }
  q=L->elem+i-1;
  for(p=L->elem+L->length-1;p>=q;--p) {
    *(p+1)=*p;
  }
  *q=e;
  ++L->length;
  return OK;
}

/*=============================*/
/* 删除元素，用e返回值，长度-1 */
/*=============================*/
Status ListDelete(SqList *L, int i, ElemType *e) {
  ElemType *p, *q;
  if(i<1||i>L->Length) return ERROR;
  p=L->elem+i-1;
  *e=*p;
  q=L->elem+L->length-1;
  for(++p;p<=q;++p) *(p-1)=*p;
  L->length--;
  return OK;
}

/*==================================*/
/* 遍历元素，依次对元素执行vi()操作 */
/*==================================*/
void ListTraverse(SqList L, void(*vi)(ElemType*)) {
  ElemType *p;
  int i;
  p=L.elem;
  for(i=1;i<L.length;i++) vi(p++);
}
```