---
layout: post
tags: javascript
---
闭包( closure ), 也叫词法闭包( lexical closure )或函数闭包( function closure )。语义上，闭包是一个保存了函数及其环境的记录。

在 MDN 上定义 JavaScript 中的闭包：A closure is the combination of a function and the lexical environment within which that function was declared。(闭包是一个函数以及声明该函数的词法环境的组合)。

理解词法作用域( lexical scoping )的规则--函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是在函数调用是决定的。所以，为了实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。

个人理解一个闭包必备的条件：
- 一个函数
- 该函数提供了外部访问函数内部变量的返回

## 词法作用域与闭包
```
function init() {
  var name = 'Mozilla';      // name is a local variable created by init
  function displayName() {   // displayName() is the inner function, a closure
    alert(name);             // use variable declared in the parent function
  }
  displayName();
}
init();
```
```
function makeFunc() {
  var name = 'Mozilla';
  function displayName() {
    alert(name);
  }
  return displayName;
}

var myFunc = makeFunc();
myFunc();
```

## 在循环中建立闭包
```
<p id="help">Helpful notes will appear here</p>
<p>E-mail: <input type="text" id="email" name="email"></p>
<p>Name: <input type="text" id="name" name="name"></p>
<p>Age: <input type="text" id="age" name="age"></p>
```
```
function showHelp(help) {
  document.getElementById('help').innerHTML = help;
}

function setupHelp() {
  var helpText = [
      {'id': 'email', 'help': 'Your e-mail address'},
      {'id': 'name', 'help': 'Your full name'},
      {'id': 'age', 'help': 'Your age (you must be over 16)'}
    ];

  for (var i = 0; i < helpText.length; i++) {
    var item = helpText[i];
    document.getElementById(item.id).onfocus = function() {
      showHelp(item.help);
    }
  }
}

setupHelp();
```
这是一个常见的错误，原因是因为分配给`onfocus`的函数是闭包，三个闭包都是在循环中创建，但是却共享同一个环境中的变量`itme.help`，这个变量是在函数回调时建立起来的。记住一点，嵌套的函数不会将作用域内的私有成员复制一份，也不会对绑定的变量生成静态快照(static snapshot)。

第一个解决方式：再创建一个闭包, 这里使用函数工厂。
```
function showHelp(help) {
  document.getElementById('help').innerHTML = help;
}

function makeHelpCallback(help) {
  return function() {
    showHelp(help);
  };
}

function setupHelp() {
  var helpText = [
      {'id': 'email', 'help': 'Your e-mail address'},
      {'id': 'name', 'help': 'Your full name'},
      {'id': 'age', 'help': 'Your age (you must be over 16)'}
    ];

  for (var i = 0; i < helpText.length; i++) {
    var item = helpText[i];
    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);
  }
}

setupHelp();
```
第二个解决方式：使用匿名闭包函数。
```
function showHelp(help) {
  document.getElementById('help').innerHTML = help;
}

function setupHelp() {
  var helpText = [
      {'id': 'email', 'help': 'Your e-mail address'},
      {'id': 'name', 'help': 'Your full name'},
      {'id': 'age', 'help': 'Your age (you must be over 16)'}
    ];

  for (var i = 0; i < helpText.length; i++) {
    // Immediate event listener attachment with the current value of item (preserved until iteration).
    (function() {
       var item = helpText[i];
       document.getElementById(item.id).onfocus = function() {
         showHelp(item.help);
       }
    })();
  }
}

setupHelp();
```

第三个解决方式：使用ES2015中的let关键字
```
function showHelp(help) {
  document.getElementById('help').innerHTML = help;
}

function setupHelp() {
  var helpText = [
      {'id': 'email', 'help': 'Your e-mail address'},
      {'id': 'name', 'help': 'Your full name'},
      {'id': 'age', 'help': 'Your age (you must be over 16)'}
    ];

  for (var i = 0; i < helpText.length; i++) {
    let item = helpText[i];
    document.getElementById(item.id).onfocus = function() {
      showHelp(item.help);
    }
  }
}

setupHelp();
```

第四个解决方式：使用`forEach`迭代`helpText`数组并且对每个`<div>`绑定一个监听器。
```
function showHelp(help) {
  document.getElementById('help').innerHTML = help;
}

function setupHelp() {
  var helpText = [
      {'id': 'email', 'help': 'Your e-mail address'},
      {'id': 'name', 'help': 'Your full name'},
      {'id': 'age', 'help': 'Your age (you must be over 16)'}
    ];

  helpText.forEach(function(text) {
    document.getElementById(text.id).onfocus = function() {
      showHelp(text.help);
    }
  });
}

setupHelp();
```

## 用途
- 读取函数内部的变量，使用闭包模拟私有方法
- 变量的值始终保持在内存中，不会在函数调用后被自动清除

## 注意点
- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。解决方法是，在退出函数之前，将不使用的局部变量全部删除

## 参考链接
- 《JavaScript权威指南(第六版)》
- 《JavaScript高级程序设计(第三版)》
- [MDN: Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
- [维基百科: Closure](https://en.wikipedia.org/wiki/Closure_(computer_programming))
- [学习Javascript闭包（Closure）](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)
