---
layout: post
tags: 2021 algorithm
title: 设计模式之单例模式
---

单例模式（Singleton Design Pattern），一个类只允许创建一个对象（或者实例），这个类就是一个单例类，这种设计模式被叫做单例设计模式。

## 为什么要用单例？

1. 资源访问冲突

   当我们定义一个类的时候，若在不同的对象都创建该类，那么可能存在相互覆盖的问题。通过设计成一个单例类，在程序中只允许创建一个对象，所有的线程共享使用该对象，就可以避免会互相覆盖的问题。

2. 全局唯一类

   配置信息类等在系统只应保存一份的东西。

单例模式与全局变量，全局变量必须在程序一开始就创建好对象，如果这个对象非常消耗资源，而程序在这次执行过程中又一直没用到它，就会非常浪费资源。利用单例模式，则在需要的时候，才创建对象。同时单例模式确保对象只会被初始化一次。

## 实现单例

![img]({{ "images/DP_singleton_uml.svg" | relative_url }})

用 Java 实现一个经典的单例模式

```java
public class Singleton {
  private static Singleton uniqueInstance;

  private Singleton() {}

  public static Singleton getInstance() {
    if (uniqueInstance == null) {
      uniqueInstance = new Singleton();
    }
    return uniqueInstance;
  }
}
```

## 单例存在的问题

1. 单例对 OOP 特性的支持不友好
2. 单例会隐藏类之间的依赖关系
3. 单例对代码扩展性不友好
4. 单例对代码的可测性不友好
5. 单例不支持有参数的构造函数

## 替代解决办法

为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。

### 如何理解单例模式中的唯一性

单例模式创建的对象是进程唯一的。单例类在进程中存在且只能存在一个对象，但在进程间是不唯一的。

### 如何实现线程唯一的单例

可以通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。

### 如何实现集群环境下的单例

我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。

### 如何实现一个多例模式

“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个 Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。

## 参考链接

- [极客时间：设计模式之美](https://time.geekbang.org/column/article/194035)
- 《Head First 设计模式》
