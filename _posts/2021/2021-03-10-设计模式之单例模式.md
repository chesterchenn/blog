---
layout: post
tags: 2021 algorithm
title: 设计模式之单例模式
---
单例模式（Singleton Design Pattern），一个类只允许创建一个对象（或者实例），这个类就是一个单例类，这种设计模式被叫做单例设计模式。

## 为什么要用单例？

#### 1. 处理资源访问冲突
当我们定义一个类的时候，若在不同的对象都创建该类，那么可能存在相互覆盖的问题。通过设计成一个单例类，在程序中只允许创建一个对象，所有的线程共享使用该对象，就可以避免会互相覆盖的问题。

#### 2. 表示全局唯一类
配置信息类等在系统只应保存一份的东西，比较适合设计成单例类。

## 如何实现一个单例？
- 构造函数需要是 private 访问权限，这样子才能避免外部通过 new 创建实例；
- 考虑对象创建时的线程安全问题；
- 考虑是否支持延迟加载；
- 考虑 getInstance() 性能是否够高（是否加锁）;

#### 1. 饿汉式
在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过不支持延迟加载。

#### 2. 懒汉式
懒汉式相对懒汉式优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。

#### 3. 双重检测
双重检测实现方式既支持延迟加载，又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。

#### 4. 静态内部类
利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持并高发，实现起来也比双重检测简单。

#### 5. 枚举
最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了创建实例线程的线程安全行和实例的唯一性。

### 单例存在的问题
1. 单例对 OOP 特性的支持不友好
2. 单例会隐藏类之间的依赖关系
3. 单例对代码扩展性不友好
4. 单例对代码的可测性不友好
5. 单例不支持有参数的构造函数

### 替代解决办法
为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。

### 如何理解单例模式中的唯一性
单例模式创建的对象是进程唯一的。单例类在进程中存在且只能存在一个对象，但在进程间是不唯一的。

### 如何实现线程唯一的单例
可以通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。

### 如何实现集群环境下的单例
我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。

### 如何实现一个多例模式
“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个 Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。

## 参考链接
- [极客时间：设计模式之美](https://time.geekbang.org/column/article/194035)