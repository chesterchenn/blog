---
layout: post
tags: javascript others
title: 浮点数
---
在 JS 中学习 0.1 + 0.2 == 0.30000000000000004 的问题时候，引申出来浮点数的学习。

## 什么是浮点数

浮点数的意思是指，小数点的位置是漂浮不定的。浮点数是采用科学计数法表示的。如十进制的小数 1.234 用不同的科学计数法表示：

- 1.234 = 1.234 * 10^0
- 1.234 = 12.34 * 10^-1
- 1.234 = 123.4 * 10^-2
- ...

格式可以写成：`V = (-1)^S * M * R^E`

- S: 符号位，取值 0 或 1，决定数字的符号，0 表示正，1 表示负
- M: 尾数，用小数表示，如 1.234 * 10^0，1.234 就是尾数
- R: 基数，表示十进制时，基数 R 就是 10，表示二进制的时，基数 R 就是 2
- E: 指数，用整数表示，例如 10^-2，-2 就是指数

## IEEE 754 标准

1985 年 IEEE(电气与电子工程师协会)推出了一套浮点数表示和运算规则，使得浮点数就有可移植性。该标准全称 IEEE 二进制浮点数算术标准，编号 IEEE 754-1985。2008 年对其改进得到我们现在使用的标准 IEEE 754-2008。

IEEE 754 提供了 4 个精度级别的浮点数定义：单精度，双精度，扩展精度和可扩展精度。JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数。

- 单精度浮点数：32 位，符号位占 1 位，指数占 8 位，尾数占 23 位
- 爽精度浮点数：64 位，符号位占 1 位，指数占 11 位，尾数占 52 位

## IEEE 754 定义或简称

LSB: least significant bit 最低有效位，指的是一个二进制数字中的第 0 位

MSB: most significant bit 最高有效位，指的是一个二进制数字中的 n - 1 位

exponent: 指数，有限浮点表示法的组成部分，表示在确定该浮点表示的值时基数的整数次幂。将有效位视为整数位和小数字段时使用指数 e，将有效位视为整数时视为指数 q；e = q + p - 1，其中 p 是数字格式的精度。

biased exponent: 偏置指数，指数和选择的常数（偏置）的总和，以使偏置指数的范围为非负。

trailing significant field: 编码二进制或十进制浮点格式的一个组成部分，包含除前导数字之外的所有有效数字。

significant：有效数，包含有效数字的有限浮点数的组成部分。

precision: 精度，可以在格式中表示的有效数字最大数量 p，或者结果四舍五入的位数。

## IEEE 754 编码规范

每个浮点数只有一种二进制交换格式的编码。

IEEE 754 的二进制编码由 3 部分组成，分别是:

- sign（符号位）0 表示正，1 表示负，占 1bit。
- based exponent（基于偏移的阶码域）
- fraction（尾数）

![float_point_format]({{ "images/float_point_format.jpg" | relative_url }})

同时还规范：

1. 尾数的第一位总是 1，因此这个 1 可以省略不写，它是个隐藏位
2. 指数是个无符号整数，指数可以负的，规定指数在原本的值加中间数。8 bit 的中间数是 127(0111 1111)，11 bit 的中间数是 1023(011 1111 1111)
3. 当存储空间无法存储完整的无限循环小数，IEEE 754 采用 round to nearest, tie to even(舍入到最接近可以表示的值，优先取偶数) 的舍入模式

## IEEE 754 的浮点数计算方法

我们试着将 25.125 转换成单精度的浮点数

1. 整数部分：25(D) = 11001(B)
2. 小数部分：0.125(D) = 0.001(B)
3. 二进制科学计数法表示：11001.001(B) = 1.1001001 * 2^4(B)
4. 符号位为 0，指数 4 + 127 = 131(D) = 1000 0011(B)，尾数去掉隐藏位 1 后为 1001001

最后的结果为 `0|10000011|10010010000000000000000`

## 0.1 + 0.2 的问题

让我们回到最初的 0.1 + 0.2 的问题上，主要原因是因为 0.1 和 0.2 在转成 IEEE 754 标准浮点数的二进制上会有精度损失。

0.2 转换为二进制的过程是不断乘以 2，直到不存在小数为止。

```plain
0.2 * 2 = 0.4 -> 0
0.4 * 2 = 0.8 -> 0
0.8 * 2 = 1.6 -> 1
0.6 * 2 = 1.2 -> 1
...(开始循环)
```

所以我们得到 0.2(D) = 0.0011...(B), 根据上面的计算方法等到双精度

1. 整数部分为 0(D) = 0(B)
2. 小数部分为 0.2(D) = 0.00110011...(B)
3. 二进制科学计数法表示：0.00110011...(B) = 1.10011...(B) * 2^-3(B)
4. 符号位为 0，指数 -3 + 127 = 124(D) = 011 1111 1100(B)，尾数去掉隐藏位 1 后为 100110011...(B)
5. 由于其舍入方式，尾数 10011...0011001(10011) 成 10011...0011010

最后的结果为 `0|011 1111 1100|10011...0011010`

同理得到 0.1 的结果为 `0|011 1111 1011|10011...0011010`

实际存储的位模式作为操作数进行浮点数加法，得到 `0|011 1111 1101|00110..0110100`, 得到结果为 0.30000000000000004

## 参考链接

- [IEEE Standard for Floating-Point Arithmetic](https://irem.univ-reunion.fr/IMG/pdf/ieee-754-2008.pdf)
- [https://0.30000000000000004.com](https://0.30000000000000004.com)
- [JS魔法堂：彻底理解0.1 + 0.2 === 0.30000000000000004的背后](https://www.cnblogs.com/fsjohnhuang/p/5115672.html)
- [基础野：细说浮点数](https://www.cnblogs.com/fsjohnhuang/p/5109766.html)
- [什么是浮点数？](https://zhuanlan.zhihu.com/p/339949186)
- [在线浮点数转二进制](https://tooltt.com/floatconverter/)
