---
layout: post
tags: 2021 algorithm
title: 设计模式类别与分类
---

设计模式主要分成三个类别。

## 设计模式的分类

<html>
<table>
  <tr>
    <th colspan="5" style="text-align: center">GoF 模式</th>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>创建型</td>
    <td>结构型</td>
    <td>行为型</td>
  </tr>
  <tr>
    <td rowspan="2">应用范围</td>
    <td>应用于类</td>
    <td>Factory Method</td>
    <td>Adapter</td>
    <td>Interpreter <br> Template Method</td>
  </tr>
  <tr>
    <td>应用于对象</td>
    <td>Abstract Factory <br> Builder <br> Prototype <br> Singleton</td>
    <td>Adapter <br> Bridge <br> Composite <br> Decorator <br> Facade <br> Flyweight <br> Proxy</td>
    <td>Chain of Responsiblity <br> Iterator <br> Mediator <br> Observer <br> State<br> Strategy <br> Visitor</td>
  </tr>
</table>
</html>

### 创建型设计模式

创建型模式：基于创建对象的概念，创建型设计模式专注于处理对象创建机制，以合适给定情况的方式来创建对象。

创建对象的基本方法可能导致项目复杂性增加，而这些模式旨在通过控制创建过程来解决这种问题。

| 类             |          |                                            |
| -------------- | -------- | ------------------------------------------ |
| Factory Method | 工厂方法 | 基于接口数据或事件生成几个派生类的一个实例 |

| 对象             |          |                                              |
| ---------------- | -------- | -------------------------------------------- |
| Abstract Factory | 抽象工厂 | 创建若干类系列的一个实例，无需详述具体的类   |
| Builder          | 生成器   | 从表示中分离对象构建；总是创建相同类型的对象 |
| Factor           | 工厂     |                                              |
| Prototype        | 原型     | 用于复制或克隆完全初始化的实例               |
| Singleton        | 单例     | 一个类在全局访问点只有唯一一个实例           |

### 结构型设计模式

结构型设计模式与对象组合有关，通常可以用与找出在不同对象之间建立关系的简单方法。这种模式有助于确保在系统某一部分发生变化时，系统的整个结构不需要同时改变。

同时对于不适合因某一特定目的而改变的系统部分，这种模式也能够帮助它们完成重组。

| 类      |        |                                                          |
| ------- | ------ | -------------------------------------------------------- |
| Adapter | 适配器 | 匹配不同类的接口，因此类可以在不兼容接口的情况下共同工作 |

| 对象      |      |                                                        |
| --------- | ---- | ------------------------------------------------------ |
| Builder   | 桥接 | 将对象接口从其实现中分离，因此他们可以独立进行变化     |
| Composite | 组合 | 简单和复合对象的结构，使对象的总和不只是它各部分的总和 |
| Decorator | 装饰 | 向对象动态添加备选的处理                               |
| Facade    | 外观 | 隐藏整个子系统复杂性的唯一一个类                       |
| Flyweight | 享元 | 一个用于实现包含在别处信息的高效共享的细粒度实例       |
| Proxy     | 代理 | 占位符对象代表真正的对象                               |

### 行为设计模式

行为模式专注与改善或简化系统中不同对象之间的通信。

| 类              |          |
| --------------- | -------- | ------------------------------------------------------ |
| Iterator        | 解释器   | 将语言元素包含在应用程序中的方法，以匹配预期语言的语法 |
| Template Method | 模板方法 | 在方法中创建算法的 shell，然后将确切的步骤推到子类     |

| 对象                   |        |                                                        |
| ---------------------- | ------ | ------------------------------------------------------ |
| Chain of Responsiblity | 指责链 | 在对象链之间传递请求的方法，以找到能够处理请求的对象   |
| Command                | 命令   | 将命令执行从其调用程序中分离的方法                     |
| Iterator               | 迭代器 | 顺序访问一个集合中的元素，无需了解该集合的内部工作原理 |
| Mediator               | 中介者 | 在类之间定义简化的通信，以防止一组类显式引用彼此       |
| Memento                | 备忘录 | 捕获对象的内部状态，以能够在以后恢复它                 |
| Observer               | 观察者 | 向多个类同志改变的方式，以确保类之间的一致性           |
| State                  | 状态   | 状态改变时，更改对象的行为                             |
| Strategy               | 策略   | 在一个类中封装算法，将选择与实现分离                   |
| Visitor                | 访问者 | 向类添加一个新的操作，无需改变类                       |

## 重构关键技法

- 静态 -> 动态
- 早绑定 -> 晚绑定
- 继承 -> 组合
- 编译时依赖 -> 运行时依赖
- 紧耦合 -> 松耦合

## 参考链接

- 《JavaScript 设计模式》第 7 章，第 8 章
