---
layout: post
tags: 2021 algorithm
title: 设计模式类别与分类
---

设计模式主要分成三个类别。

## 设计模式的类别

### 创建型设计模式

创建型设计模式专注于处理对象创建机制，以合适给定情况的方式来创建对象。创建对象的基本方法可能导致项目复杂性增加，而这些模式旨在通过控制创建过程来解决这种问题。

属于这个类别的模式有：

- Constructor（构造器）
- Factory（工厂）
- Abstract（抽象）
- Prototype（原型）
- Singleton（单例）
- Builder（生成器）

### 结构型设计模式

结构型设计模式与对象组合有关，通常可以用与找出在不同对象之间建立关系的简单方法。这种模式有助于确保在系统某一部分发生变化时，系统的整个结构不需要同时改变。

同时对于不适合因某一特定目的而改变的系统部分，这种模式也能够帮助它们完成重组。

属于这个类别的模式有：

- Decorator（装饰者）
- Facade（外观）
- Flyweight（享元）
- Adapter（适配器）
- Proxy（代理）

### 行为设计模式

行为模式专注与改善或简化系统中不同对象之间的通信。

属于这个类别的模式有：

- Iterator（迭代器）
- Mediator（中介者）
- Observer（观察者）
- Visitor（访问者）

## 设计模式的分类

创建型模式：基于创建对象的概念

| 类 ||
| 工厂方法 | 基于接口数据或事件生成几个派生类的一个实例 |
| 对象||
| 抽象工厂 | 创建若干类系列的一个实例，无需详述具体的类 |
| 生成器 | 从表示中分离对象构建；总是创建相同类型的对象 |
| 原型 | 用于复制或克隆完全初始化的实例 |
| 单例 | 一个类在全局访问点只有唯一一个实例 |

结构性模式：基于构建对象块的想法

| 类 ||
| 适配器 | 匹配不同类的接口，因此类可以在不兼容接口的情况下共同工作 |
| 对象 ||
| 桥接 | 将对象接口从其实现中分离，因此他们可以独立进行变化 |
| 组合 | 简单和复合对象的结构，使对象的总和不只是它各部分的总和 |
| 装饰 | 向对象动态添加备选的处理 |
| 外观 | 隐藏整个子系统复杂性的唯一一个类 |
| 享元 | 一个用于实现包含在别处信息的高效共享的细粒度实例 |
| 代理 | 占位符对象代表真正的对象 |

行为模式：基于对象在一起配合工作的方式

| 类 ||
| 解释器 | 将语言元素包含在应用程序中的方法，以匹配预期语言的语法 |
| 模板方法 | 在方法中创建算法的 shell，然后将确切的步骤推到子类 |
| 对象 ||
| 指责链 | 在对象链之间传递请求的方法，以找到能够处理请求的对象 |
| 命令 | 将命令执行从其调用程序中分离的方法 |
| 迭代器 | 顺序访问一个集合中的元素，无需了解该集合的内部工作原理 |
| 中介者 | 在类之间定义简化的通信，以防止一组类显式引用彼此 |
| 备忘录 | 捕获对象的内部状态，以能够在以后恢复它 |
| 观察者 | 向多个类同志改变的方式，以确保类之间的一致性 |
| 状态 | 状态改变时，更改对象的行为 |
| 策略 | 在一个类中封装算法，将选择与实现分离 |
| 访问者 | 向类添加一个新的操作，无需改变类 |

## 参考链接

- 《JavaScript设计模式》第7章，第8章
