---
layout: post
tags: 2023 react
title: React 文档笔记
---

阅读 React 官方文档的部分笔记。

<!-- vim-markdown-toc GFM -->

- [Suspense](#suspense)
  - [Props](#props)
  - [注意事项](#注意事项)
- [内嵌组件的函数定义](#内嵌组件的函数定义)
- [参考链接](#参考链接)

<!-- vim-markdown-toc -->

## Suspense

`<Suspense>` 展示一个备用组件（一般是 Loading），直到子组件完成加载。

```jsx
<Suspense fallback={<Loading />}>
  <SomeComponent />
</Suspense>
```

### Props

- `children`：实际要渲染的 UI，如果 `children` 正在渲染，那么 Suspense 就会渲染 `fallback`。
- `fallback`：如果实际上要渲染的 UI 还没完全加载，则渲染一个替代的 UI 来代替它。

### 注意事项

- React 不会为那些在首次加载前被暂停的渲染保留任何状态。当组件加载完毕后，React 会重新尝试从头开始渲染被暂停的树。
- 如果 Suspense 正在显示内容，但又被暂停了，那么它会重新显示成 fallback。除非由 `startTransition` 或 `useDeferredValue` 引发的更新。
- Suspense 的再次隐藏复现，会触发布局副作用。

## 内嵌组件的函数定义

在组件内部定义另一个函数组件，这是一个不正确的做法，因为每次组件重新渲染的时候，内部定义的组件会重新初始化。

```jsx
import { useState } from 'react';

export default function MyComponent() {
  const [counter, setCounter] = useState(0);

  function MyTextField() {
    const [text, setText] = useState('');

    return <input value={text} onChange={(e) => setText(e.target.value)} />;
  }

  return (
    <>
      <MyTextField />
      <button
        onClick={() => {
          setCounter(counter + 1);
        }}
      >
        Clicked {counter} times
      </button>
    </>
  );
}
```

上面是来自官方的例子：[xenodochial-colden-957ggf](https://codesandbox.io/s/957ggf?file=%2FApp.js&utm_medium=sandpack)

当我们点击按钮时，组件重新渲染更新，`MyTextField` 函数会被重新创建一次，只是每次在相同的位置创建了不同的实例组件。

为避免该问题，总是在顶层定义函数，切勿在函数内部嵌定义函数。

## 参考链接

- [\<Suspense\>](https://react.dev/reference/react/Suspense)
- [Preserving and Resetting State - React](https://react.dev/learn/preserving-and-resetting-state#different-components-at-the-same-position-reset-state)
