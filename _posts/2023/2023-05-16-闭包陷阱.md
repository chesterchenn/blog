---
layout: post
tags: 2023 react javascript
title: 闭包陷阱
---

闭包陷阱也叫 Capture Value，指函数式组件每次 render 都会产生一个新的函数，这个函数会产生一个在当前阶段的闭包。

## 例子

在下面例子中，先点击 alert 按钮，后面点击 add 按钮，那么弹窗的值和页面展示的 value 是什么？

```jsx
const FunctionComponent = () => {
  const [value, setValue] = useState(1);

  const log = () => {
    setTimeout(() => {
      alert(value);
    }, 3000);
  };

  return (
    <div>
      <p>FunctionComponent</p>

      <div>value: {value}</div>

      <button onClick={log}>alert</button>

      <button onClick={() => setValue(value + 1)}>add</button>
    </div>
  );
};
```

答案是：弹出的值是 1，页面的值是 2

我们发现弹出的值和当前页面显示的值不相同，这个就是一个闭包陷阱。

1. 初次渲染，生成一个 log 函数（value = 1）
2. 点击 alert 按钮，执行 log 函数（value = 1）
3. 点击 add 按钮，value 的值增加，组件重新渲染，生成一个新的 log 函数（value = 2）
4. 计时器触发，log 函数（value = 1）弹出闭包内的 value(1)

## 使用 useRef 解决闭包陷阱

使用 useRef 每次渲染是都返回同一个引用类型的对象，读取和设置 value 都在这个对象上处理。

```jsx
const FunctionComponent = () => {
  const [value, setValue] = useState(1);

  const countRef = useRef(value);

  const log = () => {
    setTimeout(() => {
      alert(countRef.current);
    }, 3000);
  };

  useEffect(() => {
    countRef.current = value;
  }, [value]);

  return (
    <div>
      <p>FunctionComponent</p>

      <div>value: {value}</div>

      <button onClick={log}>alert</button>

      <button onClick={() => setValue(value + 1)}>add</button>
    </div>
  );
};
```

## 参考链接

- [闭包陷阱](https://fe.ecool.fun/topic/207b117b-2e93-4760-91ed-8e618a85a50e?orderBy=updateTime&order=desc&tagId=13)
