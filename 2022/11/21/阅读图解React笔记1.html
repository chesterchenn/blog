<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>阅读图解React笔记1 | 主页</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="阅读图解React笔记1" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文仅仅是阅读 图解 React 原理系列 的笔记，了解更多内容请查看原文链接。" />
<meta property="og:description" content="本文仅仅是阅读 图解 React 原理系列 的笔记，了解更多内容请查看原文链接。" />
<link rel="canonical" href="/blog/2022/11/21/%E9%98%85%E8%AF%BB%E5%9B%BE%E8%A7%A3React%E7%AC%94%E8%AE%B01.html" />
<meta property="og:url" content="/blog/2022/11/21/%E9%98%85%E8%AF%BB%E5%9B%BE%E8%A7%A3React%E7%AC%94%E8%AE%B01.html" />
<meta property="og:site_name" content="主页" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-11-21T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="阅读图解React笔记1" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-21T00:00:00+00:00","datePublished":"2022-11-21T00:00:00+00:00","description":"本文仅仅是阅读 图解 React 原理系列 的笔记，了解更多内容请查看原文链接。","headline":"阅读图解React笔记1","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2022/11/21/%E9%98%85%E8%AF%BB%E5%9B%BE%E8%A7%A3React%E7%AC%94%E8%AE%B01.html"},"url":"/blog/2022/11/21/%E9%98%85%E8%AF%BB%E5%9B%BE%E8%A7%A3React%E7%AC%94%E8%AE%B01.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css">
  <link rel="icon" type="image/x-icon" href="/blog/assets/favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" /><link type="application/atom+xml" rel="alternate" href="/blog/feed.xml" title="主页" />
    






  
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">主页</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/about/">关于</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">阅读图解React笔记1</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-11-21T00:00:00+00:00" itemprop="datePublished">Nov 21, 2022
      </time></p>
    <span>
      
        <!--  -->
        <span class="highligher-rouge"><a href="/blog/tag/2022"><i>2022</i></a></span>
      
        <!--  -->
        <span class="highligher-rouge"><a href="/blog/tag/react"><i>react</i></a></span>
      
    </span>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>本文仅仅是阅读 <a href="https://7kms.github.io/react-illustration-series/">图解 React 原理系列</a> 的笔记，了解更多内容请查看原文链接。</p>

<!-- vim-markdown-toc GFM -->

<ul>
  <li><a href="#宏观介绍">宏观介绍</a></li>
  <li><a href="#循环">循环</a>
    <ul>
      <li><a href="#区别与联系">区别与联系</a></li>
      <li><a href="#主干逻辑">主干逻辑</a></li>
    </ul>
  </li>
  <li><a href="#react">React</a>
    <ul>
      <li><a href="#reactelement">ReactElement</a></li>
      <li><a href="#reactcomponent">ReactComponent</a></li>
      <li><a href="#其他组件">其他组件</a></li>
    </ul>
  </li>
  <li><a href="#react-reconciler">React-reconciler</a>
    <ul>
      <li><a href="#fiber">Fiber</a></li>
      <li><a href="#update-与-updatequeue">Update 与 UpdateQueue</a></li>
      <li><a href="#hook">Hook</a></li>
    </ul>
  </li>
  <li><a href="#scheduler">Scheduler</a>
    <ul>
      <li><a href="#task">Task</a></li>
    </ul>
  </li>
  <li><a href="#参考链接">参考链接</a></li>
</ul>

<!-- vim-markdown-toc -->

<h2 id="宏观介绍">宏观介绍</h2>

<p>React 下有 34 个包，Web 相关的核心包有 4 各，分别是 react，react-dom，react-reconciler 和 scheduler。</p>

<ol>
  <li>
    <p>react</p>

    <p>只提供了 react 组件的必要函数，需要和渲染器(react-dom)一并使用。</p>
  </li>
  <li>
    <p>react-dom</p>

    <p>react 渲染器之一，将 react-reconciler 的运行结果输出到 web 上。</p>

    <ul>
      <li>引导 react 应用的启动（通过 ReactDOM.render）</li>
      <li>实现 HostConfig 协议（ReactDOMHostConfig.js），能够将 react-reconciler 包构造出来的 fiber 树表现出来，生成 DOM 节点。</li>
    </ul>
  </li>
  <li>
    <p>react-reconciler</p>

    <p>react 调和机制，接受输入（shceduleUpdateOnFiber），将 fiber 树生成逻辑封装到一个回调函数（涉及 fiber 树形结构，fiber.updateQueue 队列，调和算法等）中。将此回调函数送入 scheduler 进行调度。</p>

    <ul>
      <li>装载渲染器，保证在需要的时候，能够正确调用渲染器的 API，生成实际节点。</li>
      <li>接收 react-dom 包 和 react 包发起的更新请求。</li>
      <li>将 fiber 树的构造过程包装在一个回调函数中，将其传给 scheduler 等待调度。</li>
    </ul>
  </li>
  <li>
    <p>scheduler</p>

    <p>调度机制的实现，控制由 react-reconciler 送入的回调函数执行时机。</p>

    <ul>
      <li>将 react-reconciler 提供的回调函数，包装到一个任务对象中。</li>
      <li>在内部维护一个任务队列，优先级高的排在最前面。</li>
      <li>循环消费任务队列，直到任务队列清空。</li>
    </ul>
  </li>
</ol>

<p><img src="/blog/images/react-core-packages.webp" alt="" /></p>

<h2 id="循环">循环</h2>

<p>在上面图中，可以看到两大循环，任务调度循环和 fiber 构建循环。</p>

<ol>
  <li>
    <p>任务调度循环，源码位于 scheduler.js，控制所有任务的调度</p>
  </li>
  <li>
    <p>Fiber 构建循环，源码位于 ReactFiberWorkLoop.js，控制整个 fiber 树的构造，整个过程是一个深度优先遍历。</p>
  </li>
</ol>

<h3 id="区别与联系">区别与联系</h3>

<p>两者的主要区别：</p>

<ul>
  <li>任务调度循环是以二叉堆为数据结构，循环执行堆的顶点，直到堆被清空</li>
  <li>任务调度循环的逻辑偏向宏观，它调度的是每个任务，不需要关心任务具体是什么的。具体任务其实就是执行回调 performSyncWorkOnRoot 或 performConcurrentWorkOnRoot</li>
  <li>fiber 构造循环是以树为数据结构，从上至下执行深度优先遍历</li>
  <li>fiber 构造循环的逻辑偏向于具体实现，是任务中一部分，只负责 fiber 树的构造</li>
</ul>

<h3 id="主干逻辑">主干逻辑</h3>

<p>通过上文的描述, 两大循环的分工可以总结为: 大循环(任务调度循环)负责调度 task, 小循环(fiber 构造循环)负责实现 task .</p>

<p>react 运行的主干逻辑, 即将输入转换为输出的核心步骤, 实际上就是围绕这两大工作循环进行展开.</p>

<p>结合上文的宏观概览图(展示核心包之间的调用关系), 可以将 react 运行的主干逻辑进行概括:</p>

<ol>
  <li>输入: 将每一次更新(如: 新增, 删除, 修改节点之后)视为一次更新需求(目的是要更新 DOM 节点).</li>
  <li>注册调度任务: react-reconciler 收到更新需求之后, 并不会立即构造 fiber 树, 而是去调度中心 scheduler 注册一个新任务 task, 即把更新需求转换成一个 task.</li>
  <li>执行调度任务(输出): 调度中心 scheduler 通过任务调度循环来执行 task(task 的执行过程又回到了 react-reconciler 包中).
    <ul>
      <li>fiber 构造循环是 task 的实现环节之一, 循环完成之后会构造出最新的 fiber 树.</li>
      <li>commitRoot 是 task 的实现环节之二, 把最新的 fiber 树最终渲染到页面上, task 完成.</li>
    </ul>
  </li>
</ol>

<h2 id="react">React</h2>

<h3 id="reactelement">ReactElement</h3>

<p>所有采用 jsx 语法书写的节点，都会被编译器转换，最终以 React.createElement(…) 的方式，创建出一个与之对应的 ReactElement 对象。</p>

<p>ReactElement 的类型定义在 shared 包的 ReactElementType.js 文件下。数据结构如下：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="nx">type</span> <span class="nx">Source</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">fileName</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span>
  <span class="na">lineNumber</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">export</span> <span class="nx">type</span> <span class="nx">ReactElement</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">$</span><span class="na">$typeof</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">type</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">key</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">ref</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">props</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="c1">// ReactFiber</span>
  <span class="na">_owner</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>

  <span class="c1">// __DEV__</span>
  <span class="na">_store</span><span class="p">:</span> <span class="p">{</span> <span class="na">validated</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">,</span> <span class="p">...</span> <span class="p">},</span>
  <span class="na">_self</span><span class="p">:</span> <span class="nx">React$Element</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="na">_shadowChildren</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">_source</span><span class="p">:</span> <span class="nx">Source</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<ol>
  <li>
    <p>key 属性在<code class="language-plaintext highlighter-rouge">reconciler</code>阶段会用到, 目前只需要知道所有的<code class="language-plaintext highlighter-rouge">ReactElement</code>对象都有 key 属性，默认值为 null。</p>
  </li>
  <li>
    <p>type 属性决定了类型的种类：</p>

    <ol>
      <li>
        <p>它有三种类型的值：字符串（div, span 等 dom 节点），函数(function, class 等节点)，react 内部定义的节点类型（portal, context, fragment 等）。它有 21 种（v18.2.0）内部定义的节点，可以在 shared/ReactSymbols.js 中查看。</p>
      </li>
      <li>
        <p>在 reconciler 阶段，会根据 type 执行不同的逻辑：</p>
        <ul>
          <li>type 是一个字符串类型，则直接使用。</li>
          <li>type 是一个 ReactComponent 类型，则会调用其 render 方法获取子节点。</li>
          <li>type 是一个 function 类型，则会调用该方法获取子节点。</li>
        </ul>
      </li>
    </ol>
  </li>
</ol>

<h3 id="reactcomponent">ReactComponent</h3>

<p>ReactComponent 是 ReactElement 中的一种类型，是最经常使用的类组件。其位置位于 react/src/ReactBaseClasses.js 文件下。</p>

<p>ReactBaseClasses 提供了两个类组件，Component 和 PureComponent。</p>

<ol>
  <li>
    <p>ReactComponent 是 class 类型，继承父类 Component，拥有特殊的方法(setState, forceUpdate)和特殊的属性(context，updater 等)</p>
  </li>
  <li>
    <p>在 reconciler 阶段，会依据 ReactElement 对象的特征，生成对应的 fiber 节点。当识别到 ReactElement 对象是 class 类型的时候，会触发 ReactComponent 对象的生命周期，并调用其 render 方法，生成 ReactElement 子节点。</p>
  </li>
</ol>

<h3 id="其他组件">其他组件</h3>

<p>function 组件也经常使用，Hook 只能在 function 类型的组件中使用。</p>

<p>如果 funciton 类型组件中没有使用 Hook，在 reconciler 阶段所有有关 Hook 的处理的都会被略过，最后调用该 function 拿到子节点 ReactElement。</p>

<p>如果使用了 Hook,逻辑就相对复杂，涉及到 Hook 的创建和状态保存。</p>

<h2 id="react-reconciler">React-reconciler</h2>

<p>react-reconciler 是 react 应用的中枢，连接渲染器(react-dom) 和调度器(scheduler)，同时本身也负责 fiber 树的构建。</p>

<p>要先知道 fiber 是核心，react 体系的渲染和更新都要以 fiber 作为数据模式，如果不能理解 fiber，也无法深入理解 react。</p>

<h3 id="fiber">Fiber</h3>

<p>Fiber 的类型定义位于 ReactInternalTypes.js 中：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">exprot</span> <span class="nx">type</span> <span class="nx">Fiber</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">tag</span><span class="p">:</span> <span class="nx">WorkTag</span><span class="p">,</span>
  <span class="na">key</span><span class="p">:</span> <span class="kc">null</span> <span class="o">|</span> <span class="nx">string</span><span class="p">,</span>
  <span class="na">elementType</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">type</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">stateNode</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">return</span><span class="p">:</span> <span class="nx">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">child</span><span class="p">:</span> <span class="nx">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">sibling</span><span class="p">:</span> <span class="nx">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">index</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>
  <span class="na">ref</span><span class="p">:</span> <span class="kc">null</span> <span class="o">|</span> <span class="p">(((</span><span class="na">hanle</span><span class="p">:</span> <span class="nx">mixed</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">{</span><span class="na">_stringRef</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span> <span class="p">...})</span> <span class="o">|</span> <span class="nx">RefObj</span><span class="p">,</span>
  <span class="nx">pendingProps</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">memoizedProps</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">dependencies</span><span class="p">:</span> <span class="nx">Dependencies</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">mode</span><span class="p">:</span> <span class="nx">TypeOfMode</span><span class="p">,</span>
  <span class="na">flags</span><span class="p">:</span> <span class="nx">Flags</span><span class="p">,</span>
  <span class="na">subtreeFlags</span><span class="p">:</span> <span class="nx">Flags</span><span class="p">,</span>
  <span class="na">deletions</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Fiber</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">nextEffect</span><span class="p">:</span> <span class="nx">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">firstEffect</span><span class="p">:</span> <span class="nx">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">lastEffect</span><span class="p">:</span> <span class="nx">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">lanes</span><span class="p">:</span> <span class="nx">Lanes</span><span class="p">,</span>
  <span class="na">childLanes</span><span class="p">:</span> <span class="nx">Lanes</span><span class="p">,</span>
  <span class="na">alternate</span><span class="p">:</span> <span class="nx">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">actualDuration</span><span class="p">?:</span> <span class="nx">number</span><span class="p">,</span>
  <span class="nx">actualStartTime</span><span class="p">?:</span> <span class="nx">number</span><span class="p">,</span>
  <span class="nx">selfBaseDuration</span><span class="p">?:</span> <span class="nx">number</span><span class="p">,</span>
  <span class="nx">treeBaseDuration</span><span class="p">?:</span> <span class="nx">number</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>相关说明：</p>

<ul>
  <li>tag：fiber 类型，根据 ReactElement 组件的 type 进行生成，在 react 内部定义了 28 种(v18.13.0)类型。其位置位于 react-reconciler/src/ReactWorkTags.js</li>
  <li>key：与 ReactElement 组件的 key 一致。</li>
  <li>elementType：一般与 ReactElement 组件的 type 一致。</li>
  <li>type：一般与 elementType 属性一致。但是在开发环境下，为了兼容热更新，会对 function, class, ForwardRef 类型的 ReactElement 做一定的处理。具体可以查看 react-reconciler/src/ReactFiber.new.js</li>
  <li>stateNode：与 fiber 相关的局部状态节点。
    <ul>
      <li>如 HostComponent 类型指向 fiber 结点对应的 DOM 节点；</li>
      <li>根结点的 stateNode 指向的是 FiberRoot；</li>
      <li>class 类型的节点 stateNode 指向的是 class 实例；</li>
    </ul>
  </li>
  <li>return：指向父结点。</li>
  <li>child：指向第一个子节点。</li>
  <li>sibling：指向下一个兄弟结点。</li>
  <li>index：fiber 在兄弟结点中的索引，如果是单节点默认为 0。</li>
  <li>ref：指向在 ReactElement 组件上设置的 ref。</li>
  <li>pendingProps：输入属性，从 ReactElement 对象传入的 props。</li>
  <li>memoizedProps：上一次生成子节点用到的属性，生成子节点之后保持在内存中。</li>
  <li>updateQueue：存储 update 更新对象的队列，每次发起更新，都需要在该队列上创建一个 update 对象。</li>
  <li>memoizedState：上一次生成子节点之后保持在内存中的局部状态。</li>
  <li>dependencies：该 fiber 节点的依赖（context, events）等。</li>
  <li>mode：二进制 Bitfield，继承至父节点，影响本 fiber 节点及其子树中的所有结点。所在文件可以查看 react-reconciler/src/ReactTypeOfMode.js</li>
  <li>flags：标志位，副作用的标记。reconciler 阶段会将所拥有 flags 标记的节点添加到副作用链中，等待 commit 阶段的处理。flags 的定义文件位于 react-reconciler/src/ReactFiberFlags.js</li>
  <li>subtreeFlags：替代 16.x 版本中的 firstEffect, nextEffect，默认未开启。</li>
  <li>deletions：存储将要被删除的子节点。默认未开启。</li>
  <li>nextEffect：单向链表，指向下一个有副作用的 fiber 节点。</li>
  <li>firstEffect：指向副作用链表中的第一个 fiber 节点。</li>
  <li>lastEffect：指向副作用链表中的最后一个 fiber 节点。</li>
  <li>lanes：本 fiber 节点所属的优先级，创建 fiber 的时候设置。</li>
  <li>childLanes：子节点所属的优先级。</li>
  <li>alternate：指向内存中的另一个 fiber,每个被更新过的 fiber 节点在内存中都是成对出现（current 和 workInProgress）。</li>
</ul>

<h3 id="update-与-updatequeue">Update 与 UpdateQueue</h3>

<p>在 fiber 对象中有一个属性 updateQueue，是一个链式队列。</p>

<p>UpdateQueue 类对象的数据结构：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="nx">type</span> <span class="nx">Update</span><span class="o">&lt;</span><span class="nx">State</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">eventTime</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>
  <span class="na">lane</span><span class="p">:</span> <span class="nx">Lane</span><span class="p">,</span>
  <span class="na">tag</span><span class="p">:</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">3</span><span class="p">,</span>
  <span class="na">payload</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">callback</span><span class="p">:</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">mixed</span><span class="p">)</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">next</span><span class="p">:</span> <span class="nx">Update</span><span class="o">&lt;</span><span class="nx">State</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">export</span> <span class="nx">type</span> <span class="nx">SharedQueue</span><span class="o">&lt;</span><span class="nx">State</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">pending</span><span class="p">:</span> <span class="nx">Update</span><span class="o">&lt;</span><span class="nx">State</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">lanes</span><span class="p">:</span> <span class="nx">Lanes</span><span class="p">,</span>
  <span class="na">hiddenCallbacks</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">mixed</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">export</span> <span class="nx">type</span> <span class="nx">UpdateQueue</span><span class="o">&lt;</span><span class="nx">State</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">baseState</span><span class="p">:</span> <span class="nx">State</span><span class="p">,</span>
  <span class="na">firstBaseUpdate</span><span class="p">:</span> <span class="nx">Update</span><span class="o">&lt;</span><span class="nx">State</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">lastBaseUpdate</span><span class="p">:</span> <span class="nx">Update</span><span class="o">&lt;</span><span class="nx">State</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">shared</span><span class="p">:</span> <span class="nx">SharedQueue</span><span class="o">&lt;</span><span class="nx">State</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="na">callbacks</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">mixed</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>相关说明：</p>

<ol>
  <li>Update
    <ul>
      <li>eventTime: 发起 update 事件的时间</li>
      <li>lane: update 所属的优先级</li>
      <li>tag: 表示 update 种类，共有 UpdateState, ReplaceState, ForceUpdate, CaptureUpdate。</li>
      <li>payload: update 对象真正需要更新的数据，可以是回调函数或者对象。</li>
      <li>callback: 回调函数，commit 完成之后调用。</li>
      <li>next：指向链表中的下一个，由于 UpdateQueue 是一个环形链表，最后一个 update.next 指向第一个 update 对象。</li>
    </ul>
  </li>
  <li>SharedQueue
    <ul>
      <li>pending: 指向即将输入的 update 队列，在类组件中调用 setState() 之后，会将新的 udpate 对象添加到这个队列中来。</li>
      <li>lanes: 所属优先级</li>
      <li>hiddenCallbacks: 隐藏的回调函数</li>
    </ul>
  </li>
  <li>SharedQueue
    <ul>
      <li>baseState: 表示此队列的基础 state</li>
      <li>firstBaseUpdate: 指向基础队列的队首</li>
      <li>lastBaseUpdate: 指向基础队列的队尾</li>
      <li>shared: 共享队列</li>
      <li>effects: 用于保存有 callback 回调函数的 update 对象，在 commit 之后，会依次调用这里的回调函数 fiber</li>
    </ul>
  </li>
</ol>

<h3 id="hook">Hook</h3>

<p>Hook 用于 function 组件中，能够保持 function 组件的状态。官方共定义了 17 种(v18.0.2) Hook 类型，文件位于 react-reconciler/src/ReactInternalTypes.js。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="nx">type</span> <span class="nx">HookType</span> <span class="o">=</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useState</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useReducer</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useContext</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useRef</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useEffect</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useInsertionEffect</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useLayoutEffect</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useCallbak</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useMemo</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useImperativeHandle</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useDebugValue</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useTranstion</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useMutableSource</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useSyncExternalStore</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useId</span><span class="dl">'</span>
  <span class="o">|</span> <span class="dl">'</span><span class="s1">useCacheRefresh</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<p>Hook 对象的数据结构，react-reconciler/src/ReactFiberHooks.js</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="nx">type</span> <span class="nx">Update</span><span class="o">&lt;</span><span class="nx">S</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">lane</span><span class="p">:</span> <span class="nx">Lane</span><span class="p">,</span>
  <span class="na">aciton</span><span class="p">:</span> <span class="nx">A</span><span class="p">,</span>
  <span class="na">hasEagerState</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">,</span>
  <span class="na">eagerState</span><span class="p">:</span> <span class="nx">S</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">next</span><span class="p">:</span> <span class="nx">Update</span><span class="o">&lt;</span><span class="nx">S</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">export</span> <span class="nx">type</span> <span class="nx">UpdateQueue</span><span class="o">&lt;</span><span class="nx">S</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">pending</span><span class="p">:</span> <span class="nx">Update</span><span class="o">&lt;</span><span class="nx">S</span><span class="p">,</span> <span class="nx">A</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">lanes</span><span class="p">:</span> <span class="nx">Lanes</span><span class="p">,</span>
  <span class="na">dispatch</span><span class="p">:</span> <span class="p">((</span><span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">mixed</span><span class="p">)</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">lastRenderedReducer</span><span class="p">:</span> <span class="p">((</span><span class="nx">S</span><span class="p">,</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">S</span><span class="p">)</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">lastRenderedState</span><span class="p">:</span> <span class="nx">S</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">export</span> <span class="nx">type</span> <span class="nx">Hook</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">memorizedState</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">baseState</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">baseQueue</span><span class="p">:</span> <span class="nx">Update</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">queue</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="na">next</span><span class="p">:</span> <span class="nx">Hook</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>相关说明：</p>

<ol>
  <li>Hook
    <ul>
      <li>memoizedState: 内存状态，用于输出最终的 fiber 树</li>
      <li>baseState: 基础状态，当 Hook.queue 更新过后，baseState 也会更新</li>
      <li>baseQueue: 基础状态队列，在 reconciler 阶段会辅助状态合并</li>
      <li>queue: 指向一个 Update 队列</li>
      <li>next: 指向该 function 组件的下一个 Hook 对象，使得多个 Hook 之间也构成一个链表。</li>
    </ul>
  </li>
  <li>Update 和 UpdateQueque (Hook.queue 和 Hook.baseQueue) 是为了保证 Hook 对象能够顺利更新，与上下文 fiber.updateQueque 中的 UpdateQueue 和 Update 是不一样的。</li>
</ol>

<p>Hook 与 fiber 的关系： 在 fiber 对象中有一个属性 fiber.memoizedState 指向 fiber 节点的内存状态。在 function 类型的组件中，fiber.memoziedState 就指向 Hook 队列。所以 Hook 也不能脱离 fiber 而存在。</p>

<h2 id="scheduler">Scheduler</h2>

<p>scheduler 负责调度，在内部维护一个任务队列 taskQueue，该队列是一个最小堆数组，其中存储了 task 对象。</p>

<h3 id="task">Task</h3>

<p>scheduler 包中，没有为 task 对象定义 type,其直接定义在 js 代码中，其文件位置 scheduler/src/forks/Scheduler.js。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">newTask</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">id</span><span class="p">:</span> <span class="nx">taskIdCounter</span><span class="o">++</span><span class="p">,</span>
  <span class="nx">callback</span><span class="p">,</span>
  <span class="nx">priorityLevel</span><span class="p">,</span>
  <span class="nx">expirationTime</span><span class="p">,</span>
  <span class="na">sortIndex</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>相关说明：</p>

<ul>
  <li>id: 唯一标识</li>
  <li>callback: task 最核心的字段，指向 react-reconciler 所提供的回调函数。</li>
  <li>priorityLevel: 优先级</li>
  <li>startTime: 一个时间戳，代表 task 的开始时间</li>
  <li>expirationTime: 过期时间</li>
  <li>sortIndex: 控制 task 在队列中的次序，值越小越靠前</li>
</ul>

<p>注意 task 中没有 next 属性，它不是一个链表，其顺序是通过堆排序来实现的。</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li><a href="https://github.com/7kms/react-illustration-series">github: react-illustration-series</a></li>
  <li><a href="https://7kms.github.io/react-illustration-series/main/macro-structure">图解 React: 基础概念</a></li>
  <li><a href="https://github.com/facebook/react">github: react</a></li>
</ul>

  </div><a class="u-url" href="/blog/2022/11/21/%E9%98%85%E8%AF%BB%E5%9B%BE%E8%A7%A3React%E7%AC%94%E8%AE%B01.html" hidden></a>
</article>

      </div>
    </main>

    <div class="top">
      <div class="top__tri"></div>
    </div><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>
  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col one-half">
      <h2 class="footer-heading">结尾处</h2>
        <ul class="contact-list">
          <li class="p-name"></li><li><a class="u-email" href="mailto:chesterchenn@outlook.com">chesterchenn@outlook.com</a></li><li>
              <a href="/blog/feed.xml">
                <svg class="svg-icon orange">
                  <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
                </svg><span>Subscribe</span>
              </a>
            </li>
        </ul>
      </div>

      <div class="footer-col one-half">
        <p>看自己超过两周之前写的代码就跟之前没看过一样。</p>
      </div>

      <div class="social-links"><ul class="social-media-list"><li><a href="https://github.com/chesterchenn" title="chesterchenn"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a href="https://twitter.com/chesterchenn" title="chesterchenn"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>
    </div>
  </div>
</footer>
<script src="/blog/assets/js/top.js"></script>

  </body>

</html>
